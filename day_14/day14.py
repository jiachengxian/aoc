import math

excess = {}

def build_quantity_map(start, map, quant_map):
    needed_quant,name = start.split(' ')
    needed_quant = int(needed_quant)
    produced_quant = int(map[name][0])

    #handle case where equation produces excess of chemical
    if needed_quant % produced_quant != 0:
        if needed_quant > produced_quant:
            #excess chemicals generated by producing 1 extra
            extra = produced_quant * math.ceil(needed_quant / produced_quant) - needed_quant
            #if have excess chemicals to possibly borrow
            if name in excess:
                #if we have enough excess to use floor of division, do so
                if needed_quant % produced_quant <= excess[name]:
                    excess[name] -= needed_quant % produced_quant
                    needed_quant = math.floor(needed_quant / produced_quant)
                #otherwise, use ceiling and store excess
                else:
                    excess[name] += extra
                    needed_quant = math.ceil(needed_quant / produced_quant)
            #otherwise, use ceiling and store excess
            else:
                excess[name] = extra
                needed_quant = math.ceil(needed_quant / produced_quant)
        else:
            if name in excess:
                #check if we have enough to borrow to produce 0
                if needed_quant <= excess[name]:
                    excess[name] -= needed_quant
                    needed_quant = 0
                #else produce 1 store excess
                else:
                    excess[name] += produced_quant - needed_quant
                    needed_quant = 1
            #else produce 1 store excess
            else:
                excess[name] = produced_quant - needed_quant
                needed_quant = 1
    #equation produces even amounts of chemical
    #but we should still check if we have enough excess to cover
    else:
        if name in excess and needed_quant < excess[name]:
            needed_quant = 0
        else:
            needed_quant = needed_quant / produced_quant

    #for each input chemical on left hand side of equation
    for c in map[name][1]:
        other_val,other_name = c.split(' ')
        scaled_val = int(needed_quant) * int(other_val)
        if other_name in quant_map:
            quant_map[other_name] += scaled_val
        else:
            quant_map[other_name] = scaled_val
        if other_name not in map.keys():
            return
        build_quantity_map(f"{scaled_val} {other_name}", map, quant_map)

def estimate_fuel(start_quant, map, max_ore):
    estimate = start_quant
    while True:
        #reset containers
        quant_map = {}
        excess = {}
        build_quantity_map(f"{estimate} FUEL", map, quant_map)
        if quant_map['ORE'] > max_ore:
            return estimate - 1
        estimate = max(estimate, math.floor(max_ore * estimate / quant_map['ORE'])) + 1

def day14():
    with open("input.txt") as f:
        input = f.readlines()
    input = [[[z.strip() for z in y.strip().split(',')] for y in x.strip().split('=>')] for x in input]

    map = {}

    for line in input:
        rs = line[1][0].split(' ')
        map[rs[1]] = (rs[0], line[0])

    #quant_map = {}
    #build_quantity_map('1 FUEL', map, quant_map)
    #print(f"We need {quant_map['ORE']} ore to produce 1 FUEL")
    
    START = 2
    MAX_ORE = 10**12
    estimate = estimate_fuel(START, map, MAX_ORE)
    print(f"Maximum amount of fuel we can produce with {MAX_ORE} ore is {estimate}")

day14()